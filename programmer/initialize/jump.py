#!/usr/bin/env python

# Lattice ECP5 jump command generator
# TN1216 p.23 describes the jump command syntax which does not work.
# The syntax has been fixed by looking at dual boot intel hex file
# generated by diamond, this actually works.

import struct
import sys

# write output of this funtion at FLASH address:
# jump_command_address = 0x3FFF00 = 4194048

# write "golden" bitstream at FLASH address:
golden_image_address = 0x140000
golden_image_address = int(sys.argv[1])

# normally both 0
reverse_bytes = 0
reverse_bits = 0

# to compare with intel HEX file generated by diamond:
# (not for normal use)
# reverse_bytes = 1
# reverse_bits = 1
# ./jump.py | hexdump -C

def reverse_Bits(n, no_of_bits):
    result = 0
    for i in range(no_of_bits):
        result <<= 1
        result |= n & 1
        n >>= 1
    return result

def uint8(n):
  if reverse_bits:
    n = reverse_Bits(n, 8)
  return struct.pack(">B", n)

def uint16(n):
  if reverse_bits:
    n = reverse_Bits(n, 16)
  if reverse_bytes:
    return struct.pack("<H", n)
  else:
    return struct.pack(">H", n)

def uint24(n):
  if reverse_bits:
    n = reverse_Bits(n, 24)
  if reverse_bytes:
    return struct.pack("<BH", n & 0xFF, n >> 8 )
  else:
    return struct.pack(">HB", n >> 8, n & 0xFF )

def uint32(n):
  if reverse_bits:
    n = reverse_Bits(n, 32)
  if reverse_bytes:
    return struct.pack("<L", n)
  else:
    return struct.pack(">L", n)

packet = b''
# Frame (START) 18 dummy bytes
packet += uint32(0xFFFFFFFF) # 4 dummy bytes
packet += uint32(0xFFFFFFFF) # 4 dummy bytes
packet += uint32(0xFFFFFFFF) # 4 dummy bytes
packet += uint32(0xFFFFFFFF) # 4 dummy bytes
packet += uint16(0xFFFF) # 2 dummy bytes (diamond generates this 2 bytes more)
# Preamble
packet += uint16(0xBDB3) # Preamble
# Frame (Control Register 0) commented out, diamond doesn't output this
# if uncommented, jump won't work:
#packet += uint8(0xC4) # Write control register 0 command
#packet += uint24(0) # 24-bit Command Information
#packet += uint32(0) # Control Register 0 data
# This is generated by diamond:
packet += uint32(0xFFFFFFFF) # I don't know what it does but it works
# Framme (Jump Command)
#packet += uint8(0xFE) # Jump command Wrong noted in TN1216
packet += uint8(0x7E) # Jump command generated by diamond
packet += uint24(0) # 24-bit Command Information
packet += uint8(0x03) # SPI Flash Read opcode (0x03 = regular read, 0x0B = fast read)
packet += uint24(golden_image_address) # 24-bit SPI Flash Sector X address
# Frame (END) 18 dummy bytes
packet += uint32(0xFFFFFFFF) # 4 dummy bytes
packet += uint32(0xFFFFFFFF) # 4 dummy bytes
packet += uint32(0xFFFFFFFF) # 4 dummy bytes
packet += uint32(0xFFFFFFFF) # 4 dummy bytes
packet += uint16(0xFFFF) # 2 dummy bytes (diamond generates this 2 bytes more)

sys.stdout.write(packet)
# print([elem.encode("hex") for elem in packet])
